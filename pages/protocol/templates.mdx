---
subtitle: Templates: The foundation of Carrot's incentivization functionality
---

## Overview of Templates

Templates are the fundamental building blocks for implementing all
incentivization functionality in Carrot. The Carrot protocol itself has zero
built-in features; instead, each feature is added as an independent template
built on top of the core set of smart contracts. Templates can be viewed as
mini-apps that run within Carrot, following its rules and extending its
functionality.

Templates are designed to be independent of one another, allowing for
interchangeability. They can be freely mixed and matched, orchestrated by the
Carrot frontend to provide users with a unified and coherent experience,
abstracting the platform's complexity and flexibility.

This architecture provides unparalleled flexibility to Carrot, enabling the
implementation of tailor-made incentivization logic and even full custom clients
dedicated to specific templates.

## Structure of Templates

Templates are composite entities consisting of an on-chain contract(s) and an
off-chain frontend. They are securely stored on-chain through dedicated smart
contracts that manage the entire lifecycle of each template, including addition,
versioning, updates, upgrades\*, instantiation, and deletions.

\*Note: Upgrades refer to future uses of a particular template. Template
instances that have already been deployed and are in use are always trustless
and immutable in Carrot.

The following data is stored on-chain for each template:

-   **ID**: Each template has a well-defined auto-incremental integer identifier
    within Carrot to facilitate operations such as upgrades.
-   **Version**: Carrot templates can be upgraded and expanded in functionality,
    allowing for updates or patches as needed. Each template has a version that
    indicates the number of updates made to it.
-   **Address**: An address that points to the template's contract. The on-chain
    logic of the template is implemented within this contract, and any template
    instance serves as a minimal proxy to this address.
-   **Specification**: The template specification includes metadata about the
    template in a JSON file, along with its frontend implementation, which may
    consist of multiple parts. Further details on the template specification
    will be provided in a dedicated section of the documentation.

Templates solely represent the **definition** of a specific logic. To be
utilized in a KPI token, they must be instantiated. Instantiation involves
deploying a minimal proxy to the template's contract, as mentioned earlier.

## Types of Templates

Carrot supports two main types of templates:

-   **Oracle templates**: As the name suggests, these templates implement logic
    to bring real-world data related to the outcome of a specific condition onto
    the blockchain. Examples range from leveraging crowdsourced oracles like
    Reality.eth and UMA's optimistic oracle to obtain general-purpose data, to
    more "static" oracles like ChainLink-based ones that bring predefined data
    onto the blockchain. Oracle templates interact with KPI tokens once an
    outcome related to a condition becomes known and needs to be communicated to
    the KPI token itself (more details on KPI tokens will be provided later in
    the documentation).
-   **KPI token templates**: KPI token templates encompass logic directly
    related to the behavior of KPI tokens. They determine the type of collateral
    accepted by KPI tokens, their structure (ERC20, NFTs, etc.), the number of
    conditions (oracles) they can handle, and how they interpret results relayed
    to them by attached oracle templates, among other features. Carrot's various
    incentivization strategies are implemented through KPI token templates.

In the next section, we will delve into the structure and role of an oracle
template within Carrot, along with the possible features that can be
implemented.
